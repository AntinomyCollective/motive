<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Motive Animation System: fpl::RangeT&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Motive Animation System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.html"><span>Building</span></a></li>
      <li><a href="usergroup1.html"><span>Programmer's&#160;Guide</span></a></li>
      <li class="current"><a href="motive_api_reference.html"><span>API&#160;Reference</span></a></li>
      <li><a href="motive_readme.html"><span>Readme</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfpl_1_1_range_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfpl_1_1_range_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fpl::RangeT&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represent an interval on a number line.  
 <a href="classfpl_1_1_range_t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="range_8h_source.html">range.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class fpl::RangeT&lt; T &gt;</h3>

<p>Represent an interval on a number line. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfpl_1_1_range_t_1_1_range_array.html">RangeArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfpl_1_1_range_t_1_1_t_array.html">TArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7ad0ec4a269b22950e39b4e321ed3b2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ad0ec4a269b22950e39b4e321ed3b2b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RangeT</b> (const T <a class="el" href="classfpl_1_1_range_t.html#a371c069c19788cbf6eb1c67b09a01897">start</a>, const T end)</td></tr>
<tr class="separator:a7ad0ec4a269b22950e39b4e321ed3b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0e742ec80a1831fef6aa9dd7529ee9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab0e742ec80a1831fef6aa9dd7529ee9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#aab0e742ec80a1831fef6aa9dd7529ee9">Valid</a> () const </td></tr>
<tr class="memdesc:aab0e742ec80a1831fef6aa9dd7529ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range is valid if it contains at least one number. <br/></td></tr>
<tr class="separator:aab0e742ec80a1831fef6aa9dd7529ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c38bff2e1d7ef30c2674bf78ed3b47"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#aa7c38bff2e1d7ef30c2674bf78ed3b47">Middle</a> () const </td></tr>
<tr class="separator:aa7c38bff2e1d7ef30c2674bf78ed3b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ae45a82c188b920c24b96f06f62354"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#aa8ae45a82c188b920c24b96f06f62354">Length</a> () const </td></tr>
<tr class="separator:aa8ae45a82c188b920c24b96f06f62354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cba8bf3b6ce55c54b88c3e2edbaf4ca"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a0cba8bf3b6ce55c54b88c3e2edbaf4ca">Clamp</a> (const T x) const </td></tr>
<tr class="separator:a0cba8bf3b6ce55c54b88c3e2edbaf4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33ab50dcdce98ae0ad10956eb1eaf1d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#ab33ab50dcdce98ae0ad10956eb1eaf1d">ClampAfterStart</a> (const T x) const </td></tr>
<tr class="separator:ab33ab50dcdce98ae0ad10956eb1eaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe970dd059f0bbfd8ee9688a4aeb3f8a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#abe970dd059f0bbfd8ee9688a4aeb3f8a">ClampBeforeEnd</a> (const T x) const </td></tr>
<tr class="separator:abe970dd059f0bbfd8ee9688a4aeb3f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b74519b2921ab408c7c02564e2a6433"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a5b74519b2921ab408c7c02564e2a6433">DistanceFrom</a> (const T x) const </td></tr>
<tr class="separator:a5b74519b2921ab408c7c02564e2a6433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511414b8c3bda04f34a3aeba88ab6c26"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a511414b8c3bda04f34a3aeba88ab6c26">Lerp</a> (const float percent) const </td></tr>
<tr class="separator:a511414b8c3bda04f34a3aeba88ab6c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72282135ce2c5357d91c0e7fceb05db"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#ab72282135ce2c5357d91c0e7fceb05db">Percent</a> (const T x) const </td></tr>
<tr class="separator:ab72282135ce2c5357d91c0e7fceb05db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26db0a24db36cdf83fa7c5e93ea12b81"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a26db0a24db36cdf83fa7c5e93ea12b81">PercentClamped</a> (const T x) const </td></tr>
<tr class="separator:a26db0a24db36cdf83fa7c5e93ea12b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa070d4d86edf9bdcf6caf80b5b2c7061"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#aa070d4d86edf9bdcf6caf80b5b2c7061">Normalize</a> (T x) const </td></tr>
<tr class="separator:aa070d4d86edf9bdcf6caf80b5b2c7061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f32a6399a268159367e09c7f4a0c6f9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a9f32a6399a268159367e09c7f4a0c6f9">NormalizeWildValue</a> (T x) const </td></tr>
<tr class="separator:a9f32a6399a268159367e09c7f4a0c6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c6fb86ad4e573f84e18425df86c410"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#af8c6fb86ad4e573f84e18425df86c410">ModularAdjustment</a> (T x) const </td></tr>
<tr class="separator:af8c6fb86ad4e573f84e18425df86c410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d63d8a275c461b4e4e1e75ec6ac7475"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a1d63d8a275c461b4e4e1e75ec6ac7475">ModDiffClose</a> (T a, T b) const </td></tr>
<tr class="separator:a1d63d8a275c461b4e4e1e75ec6ac7475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b3231203f7b440bf7e34fdd52c1c88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b3231203f7b440bf7e34fdd52c1c88"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a29b3231203f7b440bf7e34fdd52c1c88">ModDiffFar</a> (T a, T b) const </td></tr>
<tr class="memdesc:a29b3231203f7b440bf7e34fdd52c1c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the farthest difference from 'a' to 'b' under modular arithmetic. <br/></td></tr>
<tr class="separator:a29b3231203f7b440bf7e34fdd52c1c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaaf4200104bb4fe435904ac8af1c5c9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#afaaf4200104bb4fe435904ac8af1c5c9">ModDiffPositive</a> (T a, T b) const </td></tr>
<tr class="separator:afaaf4200104bb4fe435904ac8af1c5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1225e54f8b6039c08ff123b7f1025d2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#ab1225e54f8b6039c08ff123b7f1025d2">ModDiffNegative</a> (T a, T b) const </td></tr>
<tr class="separator:ab1225e54f8b6039c08ff123b7f1025d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b397b70a840ef8c2cbb54207e6c0b3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a52b397b70a840ef8c2cbb54207e6c0b3">ModDiff</a> (T a, T b, ModularDirection direction) const </td></tr>
<tr class="separator:a52b397b70a840ef8c2cbb54207e6c0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c84188b6a1ad5f6e5f94336bc70caa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c84188b6a1ad5f6e5f94336bc70caa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Contains</b> (const T x) const </td></tr>
<tr class="separator:a96c84188b6a1ad5f6e5f94336bc70caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713b880033161403da46985d79f29099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a713b880033161403da46985d79f29099">Invert</a> () const </td></tr>
<tr class="separator:a713b880033161403da46985d79f29099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8337a83f15d6a9ed13d17e9697153652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a8337a83f15d6a9ed13d17e9697153652">Lengthen</a> (const float percent) const </td></tr>
<tr class="separator:a8337a83f15d6a9ed13d17e9697153652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4074e43599d136bfecd11a8d03021d0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4074e43599d136bfecd11a8d03021d0a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a4074e43599d136bfecd11a8d03021d0a">operator==</a> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> &amp;rhs) const </td></tr>
<tr class="memdesc:a4074e43599d136bfecd11a8d03021d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality is strict. No epsilon checking here. <br/></td></tr>
<tr class="separator:a4074e43599d136bfecd11a8d03021d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1135fb91cf15916670f60e5c722847a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1135fb91cf15916670f60e5c722847a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> &amp;rhs) const </td></tr>
<tr class="separator:a1135fb91cf15916670f60e5c722847a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842da86571b2ffd6caec7e54063c4cd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a842da86571b2ffd6caec7e54063c4cd8"></a>
<a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a842da86571b2ffd6caec7e54063c4cd8">operator*</a> (const float s) const </td></tr>
<tr class="memdesc:a842da86571b2ffd6caec7e54063c4cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale by multiplying by a scalar. <br/></td></tr>
<tr class="separator:a842da86571b2ffd6caec7e54063c4cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371c069c19788cbf6eb1c67b09a01897"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a371c069c19788cbf6eb1c67b09a01897"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a371c069c19788cbf6eb1c67b09a01897">start</a> () const </td></tr>
<tr class="memdesc:a371c069c19788cbf6eb1c67b09a01897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors. <br/></td></tr>
<tr class="separator:a371c069c19788cbf6eb1c67b09a01897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4d304151eb3a055b840298dd2c40f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c4d304151eb3a055b840298dd2c40f7"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a1c4d304151eb3a055b840298dd2c40f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981e675cd93cd1eb36a89f956e056e2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a981e675cd93cd1eb36a89f956e056e2d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_start</b> (const T <a class="el" href="classfpl_1_1_range_t.html#a371c069c19788cbf6eb1c67b09a01897">start</a>)</td></tr>
<tr class="separator:a981e675cd93cd1eb36a89f956e056e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac617f079c608b0af4df87487130975"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac617f079c608b0af4df87487130975"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_end</b> (const T end)</td></tr>
<tr class="separator:a7ac617f079c608b0af4df87487130975"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5a7eccc7d4bec9b67cf53f56b0fd0f56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a5a7eccc7d4bec9b67cf53f56b0fd0f56">Intersect</a> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> &amp;a, const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> &amp;b)</td></tr>
<tr class="separator:a5a7eccc7d4bec9b67cf53f56b0fd0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7255d08a3de8edb1dafb8fd9fba85f"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#ade7255d08a3de8edb1dafb8fd9fba85f">ValuesInRange</a> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> &amp;range, T epsilon, size_t num_values, T *values)</td></tr>
<tr class="separator:ade7255d08a3de8edb1dafb8fd9fba85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7d68e5b36f677120a68ab066189482"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b7d68e5b36f677120a68ab066189482"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:a8b7d68e5b36f677120a68ab066189482"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ValuesInRange</b> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> &amp;range, T epsilon, <a class="el" href="structfpl_1_1_range_t_1_1_t_array.html">TArray</a>&lt; kMaxLen &gt; *values)</td></tr>
<tr class="separator:a8b7d68e5b36f677120a68ab066189482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9d577500a721eee4b30d5e5b8e83fe"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#a8b9d577500a721eee4b30d5e5b8e83fe">IntersectRanges</a> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> *a, size_t len_a, const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> *b, size_t len_b, <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> *intersections, <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> *gaps=nullptr, size_t *len_gaps=nullptr)</td></tr>
<tr class="separator:a8b9d577500a721eee4b30d5e5b8e83fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790fcbc4f97ac067484ac5ca897763e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a790fcbc4f97ac067484ac5ca897763e9"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:a790fcbc4f97ac067484ac5ca897763e9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IntersectRanges</b> (const <a class="el" href="structfpl_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;a, const <a class="el" href="structfpl_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;b, <a class="el" href="structfpl_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen *kMaxLen &gt; *intersections, <a class="el" href="structfpl_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen *kMaxLen &gt; *gaps=nullptr)</td></tr>
<tr class="separator:a790fcbc4f97ac067484ac5ca897763e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23520662815f3ba6c41bd5cd42aec37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac23520662815f3ba6c41bd5cd42aec37"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#ac23520662815f3ba6c41bd5cd42aec37">IndexOfLongest</a> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> *ranges, size_t len)</td></tr>
<tr class="memdesc:ac23520662815f3ba6c41bd5cd42aec37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the longest range in <code>ranges</code>. <br/></td></tr>
<tr class="separator:ac23520662815f3ba6c41bd5cd42aec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688cfb1278c08d22446cd77c6beb7e0c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a688cfb1278c08d22446cd77c6beb7e0c"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:a688cfb1278c08d22446cd77c6beb7e0c"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexOfLongest</b> (const <a class="el" href="structfpl_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;ranges)</td></tr>
<tr class="separator:a688cfb1278c08d22446cd77c6beb7e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34ddbf2ff2713fb147d0fd8702d5555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac34ddbf2ff2713fb147d0fd8702d5555"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfpl_1_1_range_t.html#ac34ddbf2ff2713fb147d0fd8702d5555">IndexOfShortest</a> (const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> *ranges, size_t len)</td></tr>
<tr class="memdesc:ac34ddbf2ff2713fb147d0fd8702d5555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the shortest range in <code>ranges</code>. <br/></td></tr>
<tr class="separator:ac34ddbf2ff2713fb147d0fd8702d5555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd7e3adcf10d99e2bb6f40758d927d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2bd7e3adcf10d99e2bb6f40758d927d5"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:a2bd7e3adcf10d99e2bb6f40758d927d5"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexOfShortest</b> (const <a class="el" href="structfpl_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;ranges)</td></tr>
<tr class="separator:a2bd7e3adcf10d99e2bb6f40758d927d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705e175fa27d70c3d83ad73bafd88f33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a705e175fa27d70c3d83ad73bafd88f33"></a>
static <a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Full</b> ()</td></tr>
<tr class="separator:a705e175fa27d70c3d83ad73bafd88f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0cba8bf3b6ce55c54b88c3e2edbaf4ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Clamp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>x</code> if it is within the range. Otherwise, returns start_ or end_, whichever is closer to <code>x</code>. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="ab33ab50dcdce98ae0ad10956eb1eaf1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ClampAfterStart </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clamp <code>x</code> so it is inside the start bound. Can save cycles if you already know that <code>x</code> is inside the end bound. </p>

</div>
</div>
<a class="anchor" id="abe970dd059f0bbfd8ee9688a4aeb3f8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ClampBeforeEnd </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clamp <code>x</code> so it is inside the end bound. Can save cycles if you already know that <code>x</code> is inside the start bound. </p>

</div>
</div>
<a class="anchor" id="a5b74519b2921ab408c7c02564e2a6433"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::DistanceFrom </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns distance outside of the range. If inside the range, returns 0. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="a5a7eccc7d4bec9b67cf53f56b0fd0f56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classfpl_1_1_range_t.html">RangeT</a> <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the overlap of 'a' and 'b', or an invalid range if they do not overlap at all. When 'a' and 'b' don't overlap at all, calling Invert on the returned range will give the gap between 'a' and 'b'. </p>

</div>
</div>
<a class="anchor" id="a8b9d577500a721eee4b30d5e5b8e83fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::IntersectRanges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>intersections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>gaps</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len_gaps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intersect every element of 'a' with every element of 'b'. Append intersections to 'intersections'. Note that 'intersections' is not reset at the start of the call. </p>

</div>
</div>
<a class="anchor" id="a713b880033161403da46985d79f29099"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfpl_1_1_range_t.html">RangeT</a> <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap start and end. When 'a' and 'b' don't overlap, if you invert the return value of Range::Intersect(a, b), you'll get the gap between 'a' and 'b'. </p>

</div>
</div>
<a class="anchor" id="aa8ae45a82c188b920c24b96f06f62354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the span of the range. Returns 0 when only one number in range. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="a8337a83f15d6a9ed13d17e9697153652"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfpl_1_1_range_t.html">RangeT</a> <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Lengthen </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>percent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range that is 'percent' longer. If 'percent' is &lt; 1.0, then returned range will actually be shorter. </p>

</div>
</div>
<a class="anchor" id="a511414b8c3bda04f34a3aeba88ab6c26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Lerp </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>percent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lerps between the start and the end. 'percent' of 0 returns start. 'percent' of 1 returns end. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="aa7c38bff2e1d7ef30c2674bf78ed3b47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Middle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the mid-point of the range, rounded down for integers. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="a52b397b70a840ef8c2cbb54207e6c0b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ModDiff </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModularDirection&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference from 'a' to 'b' that satisfies the 'direction' criteria. </p>

</div>
</div>
<a class="anchor" id="a1d63d8a275c461b4e4e1e75ec6ac7475"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ModDiffClose </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In modular arithmetic, you can get from 'a' to 'b' by going directly, or by wrapping around. Return the closest difference from 'a' to 'b' under modular arithmetic. </p>

</div>
</div>
<a class="anchor" id="ab1225e54f8b6039c08ff123b7f1025d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ModDiffNegative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference from 'a' to 'b' under modular arithmetic that is negative. </p>

</div>
</div>
<a class="anchor" id="afaaf4200104bb4fe435904ac8af1c5c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ModDiffPositive </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference from 'a' to 'b' under modular arithmetic that is positive. </p>

</div>
</div>
<a class="anchor" id="af8c6fb86ad4e573f84e18425df86c410"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ModularAdjustment </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: <a class="el" href="classfpl_1_1_range_t.html#aa8ae45a82c188b920c24b96f06f62354">Length()</a> if <code>x</code> is below the valid range -Length() if <code>x</code> is above the valid range 0 if <code>x</code> is within the valid range. </p>

</div>
</div>
<a class="anchor" id="aa070d4d86edf9bdcf6caf80b5b2c7061"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Normalize </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure <code>x</code> is within the valid constraint range, by subtracting or adding <a class="el" href="classfpl_1_1_range_t.html#aa8ae45a82c188b920c24b96f06f62354">Length()</a> to it. <code>x</code> must be within +-Length() of the range bounds. This is a reasonable restriction in most cases (such as after an arithmetic operation). For cases where <code>x</code> may be wildly outside the range, use <a class="el" href="classfpl_1_1_range_t.html#a9f32a6399a268159367e09c7f4a0c6f9">NormalizeWildValue()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a9f32a6399a268159367e09c7f4a0c6f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::NormalizeWildValue </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure <code>x</code> is within the valid constraint range, by subtracting multiples of <a class="el" href="classfpl_1_1_range_t.html#aa8ae45a82c188b920c24b96f06f62354">Length()</a> from it until it is. <code>x</code> can be any value. </p>

</div>
</div>
<a class="anchor" id="ab72282135ce2c5357d91c0e7fceb05db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::Percent </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns percent 0~1, from start to end. <em>Not</em> clamped to 0~1. 0 ==&gt; start; 1 ==&gt; end; 0.5 ==&gt; <a class="el" href="classfpl_1_1_range_t.html#aa7c38bff2e1d7ef30c2674bf78ed3b47">Middle()</a>; -1 ==&gt; start - <a class="el" href="classfpl_1_1_range_t.html#aa8ae45a82c188b920c24b96f06f62354">Length()</a> </p>

</div>
</div>
<a class="anchor" id="a26db0a24db36cdf83fa7c5e93ea12b81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::PercentClamped </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns percent 0~1, from start to end. Clamped to 0~1. 0 ==&gt; start or earlier; 1 ==&gt; end or later; 0.5 ==&gt; <a class="el" href="classfpl_1_1_range_t.html#aa7c38bff2e1d7ef30c2674bf78ed3b47">Middle()</a> </p>

</div>
</div>
<a class="anchor" id="ade7255d08a3de8edb1dafb8fd9fba85f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classfpl_1_1_range_t.html">fpl::RangeT</a>&lt; T &gt;::ValuesInRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfpl_1_1_range_t.html">RangeT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only keep entries in 'values' if they are in (range.start - epsition, range.end + epsilon). Any values that are kept are clamped to 'range'.</p>
<p>This function is useful when floating point precision error might put a value slightly outside 'range' even though mathematically it should be inside 'range'. This often happens with values right on the border of the valid range. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="range_8h_source.html">range.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-46159502-1', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>

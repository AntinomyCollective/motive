<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Motive Animation System: motive::RangeT&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
<script>
  /**
   * Check if the browser rendering this page is being run on an Android device.
   * It checks if the string 'android' is found in the browser's `userAgent`.
   * @return {boolean} This returns `true` if the browser's `userAgent` contains
   * the string 'android' (indicating that the browser is on an Android device).
   * Otherwise, it returns `false`.
   */
  function isAndroidDevice() {
    if (navigator && navigator.userAgent) {
      return navigator.userAgent.toLowerCase().indexOf('android') != -1;
    } else {
      return false;
    }
  }
  /**
   * Check if an HTML `class` attribute is in the browser-specific format.
   * @param {string} An HTML `class` attribute in the format 'browser-{device}'.
   * @return {boolean} Returns `true` if `browserClass` was in the valid format,
   * prefixed with 'browser-'. Otherwise, it returns false.
   */
  function isBrowserSpecificClassName(browserClass) {
    if (browserClass && browserClass.substring(0, 8) == 'browser-' &&
        browserClass.length > 8) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Get all the HTML Elements with browser-specific `class` attributes.
   * @return {array} Returns an array of all the HTML Elements with a `class`
   * attribute that is prefixed with `browser-`.
   */
  function getAllBrowserSpecificElements() {
    if (document) {
      var htmlElements = document.getElementsByTagName("*");
      var browserSpecificElements = [];
      for (var i = 0; i < htmlElements.length; i++) {
        if (isBrowserSpecificClassName(htmlElements[i].className)) {
          browserSpecificElements.push(htmlElements[i]);
        }
      }
      return browserSpecificElements;
    } else {
      return null;
    }
  }
  /**
   * Given a browser-specific HTML `class` attribute, extract the device name.
   * @param {string} browserClass The string name of an HTML `class` attribute,
   * in the format `browser-{device}`.
   * @return {string} Returns a string containing only the device portion of
   * the class name. If the input was invalid, then it returns `null`.
   */
  function extractDeviceFromBrowserClass(browserClass) {
    if (isBrowserSpecificClassName(browserClass)) {
      return browserClass.substring(8);
    }
    else {
      return null;
    }
  }
  /**
   * Hide device specific elements that do not apply to the current device.
   */
  function handleDeviceSpecificLoading() {
    var browserSpecificElements = getAllBrowserSpecificElements();
    for (var i = 0; i < browserSpecificElements.length; i++) {
      var device = extractDeviceFromBrowserClass(browserSpecificElements[i].className);
      if (device && !isAndroidDevice() && device == 'android') {
        browserSpecificElements[i].innerHTML = '';
      } else if(device && isAndroidDevice() && device == 'desktop') {
        browserSpecificElements[i].innerHTML = '';
      }
    }
  }
  $(document).ready(handleDeviceSpecificLoading);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Motive Animation System
   </div>
   <div style="font-size:12px;">
	 An open source project by
     <a href="https://developers.google.com/games/#Tools">FPL</a>.
  </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.html"><span>Building</span></a></li>
      <li><a href="usergroup1.html"><span>Programmer's&#160;Guide</span></a></li>
      <li class="current"><a href="motive_api_reference.html"><span>API&#160;Reference</span></a></li>
      <li><a href="motive_readme.html"><span>Readme</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmotive_1_1_range_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmotive_1_1_range_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">motive::RangeT&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represent an interval on a number line.  
 <a href="classmotive_1_1_range_t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="range_8h_source.html">range.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class motive::RangeT&lt; T &gt;</h3>

<p>Represent an interval on a number line. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmotive_1_1_range_t_1_1_t_array.html">TArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaaea5e8ecc43aa04eb4205ac1155e00c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaea5e8ecc43aa04eb4205ac1155e00c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RangeT</b> (const T point)</td></tr>
<tr class="separator:aaaea5e8ecc43aa04eb4205ac1155e00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a55ee4a8f19b21eb1014a91d83353c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a55ee4a8f19b21eb1014a91d83353c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RangeT</b> (const T <a class="el" href="classmotive_1_1_range_t.html#a6bea0f2a960a439b576c8c5811d98b57">start</a>, const T end)</td></tr>
<tr class="separator:a3a55ee4a8f19b21eb1014a91d83353c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada25bd827aad4c222e4fe6342d347cf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada25bd827aad4c222e4fe6342d347cf5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ada25bd827aad4c222e4fe6342d347cf5">Valid</a> () const </td></tr>
<tr class="memdesc:ada25bd827aad4c222e4fe6342d347cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range is valid if it contains at least one number. <br/></td></tr>
<tr class="separator:ada25bd827aad4c222e4fe6342d347cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae531b10c3ed174bf0445903e6ece2ebd"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ae531b10c3ed174bf0445903e6ece2ebd">Middle</a> () const </td></tr>
<tr class="separator:ae531b10c3ed174bf0445903e6ece2ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa92310288b7f52713948cce217fa73b"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length</a> () const </td></tr>
<tr class="separator:afa92310288b7f52713948cce217fa73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc35956e960d733f40a81160778af9c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a5dc35956e960d733f40a81160778af9c">Clamp</a> (const T x) const </td></tr>
<tr class="separator:a5dc35956e960d733f40a81160778af9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725ec57fb75410d7f8fe82eba758fcd4"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a725ec57fb75410d7f8fe82eba758fcd4">ClampAfterStart</a> (const T x) const </td></tr>
<tr class="separator:a725ec57fb75410d7f8fe82eba758fcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de954293531bb29db954a1cee4c9d89"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a9de954293531bb29db954a1cee4c9d89">ClampBeforeEnd</a> (const T x) const </td></tr>
<tr class="separator:a9de954293531bb29db954a1cee4c9d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19147d320516298553c578b9c8c4d2e8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a19147d320516298553c578b9c8c4d2e8">DistanceFrom</a> (const T x) const </td></tr>
<tr class="separator:a19147d320516298553c578b9c8c4d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c61742ac4a96681f47410d3efc9e541"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a3c61742ac4a96681f47410d3efc9e541">Lerp</a> (const float percent) const </td></tr>
<tr class="separator:a3c61742ac4a96681f47410d3efc9e541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2966ba7ac9a3f3b2c57b980b5f6fff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#afa2966ba7ac9a3f3b2c57b980b5f6fff">Percent</a> (const T x) const </td></tr>
<tr class="separator:afa2966ba7ac9a3f3b2c57b980b5f6fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8980ceb97c9dac550e353633ec732f20"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a8980ceb97c9dac550e353633ec732f20">PercentClamped</a> (const T x) const </td></tr>
<tr class="separator:a8980ceb97c9dac550e353633ec732f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e9e9a7168de1c6221ee28713b27eba"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a02e9e9a7168de1c6221ee28713b27eba">Normalize</a> (T x) const </td></tr>
<tr class="separator:a02e9e9a7168de1c6221ee28713b27eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b0cff76a3faa187c3c0078d1b934b3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a10b0cff76a3faa187c3c0078d1b934b3">NormalizeCloseValue</a> (T x) const </td></tr>
<tr class="separator:a10b0cff76a3faa187c3c0078d1b934b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae474477f86d6adbc54da2b2f15054ebe"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ae474477f86d6adbc54da2b2f15054ebe">NormalizeWildValue</a> (T x) const </td></tr>
<tr class="separator:ae474477f86d6adbc54da2b2f15054ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88728e70338d1dc1c944becd9ad43d3"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ac88728e70338d1dc1c944becd9ad43d3">ModularAdjustment</a> (T x) const </td></tr>
<tr class="separator:ac88728e70338d1dc1c944becd9ad43d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585e3a5bb49d9d376b45d770a37fcea2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a585e3a5bb49d9d376b45d770a37fcea2">ModDiffClose</a> (T a, T b) const </td></tr>
<tr class="separator:a585e3a5bb49d9d376b45d770a37fcea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13ade18361a1ee828174a942dd57649"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13ade18361a1ee828174a942dd57649"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ab13ade18361a1ee828174a942dd57649">ModDiffFar</a> (T a, T b) const </td></tr>
<tr class="memdesc:ab13ade18361a1ee828174a942dd57649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the farthest difference from 'a' to 'b' under modular arithmetic. <br/></td></tr>
<tr class="separator:ab13ade18361a1ee828174a942dd57649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8affb4d0d36e47bb3b84a998f8dae433"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a8affb4d0d36e47bb3b84a998f8dae433">ModDiffPositive</a> (T a, T b) const </td></tr>
<tr class="separator:a8affb4d0d36e47bb3b84a998f8dae433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518ce1b36483597509cc01ac373f7c1c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a518ce1b36483597509cc01ac373f7c1c">ModDiffNegative</a> (T a, T b) const </td></tr>
<tr class="separator:a518ce1b36483597509cc01ac373f7c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0610a07e387639f58f7aac571f899acb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a0610a07e387639f58f7aac571f899acb">ModDiff</a> (T a, T b, ModularDirection direction) const </td></tr>
<tr class="separator:a0610a07e387639f58f7aac571f899acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785f3c5c4d0d36d2d94df9d8d20c6037"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785f3c5c4d0d36d2d94df9d8d20c6037"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a785f3c5c4d0d36d2d94df9d8d20c6037">Contains</a> (const T x) const </td></tr>
<tr class="memdesc:a785f3c5c4d0d36d2d94df9d8d20c6037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>x</code> is in [start_, end_], i.e. the <b>inclusive</b> range. <br/></td></tr>
<tr class="separator:a785f3c5c4d0d36d2d94df9d8d20c6037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe036fb375a7c8f549649c55bc0e74a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#abfe036fb375a7c8f549649c55bc0e74a">ContainsExcludingStart</a> (const T x) const </td></tr>
<tr class="separator:abfe036fb375a7c8f549649c55bc0e74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfa9c82690b004a7587f0c06c8c4932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a2bfa9c82690b004a7587f0c06c8c4932">ContainsExcludingEnd</a> (const T x) const </td></tr>
<tr class="separator:a2bfa9c82690b004a7587f0c06c8c4932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebae973cb6a6f44357d39ff84607184"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ebae973cb6a6f44357d39ff84607184"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a5ebae973cb6a6f44357d39ff84607184">StrictlyContains</a> (const T x) const </td></tr>
<tr class="memdesc:a5ebae973cb6a6f44357d39ff84607184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <code>x</code> is in (start_, end_), i.e. the <b>exclusive</b> range. <br/></td></tr>
<tr class="separator:a5ebae973cb6a6f44357d39ff84607184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a57220d2bcbe1018421db665a18f2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a22a57220d2bcbe1018421db665a18f2d">ContainsWithTolerance</a> (const T x, const T percent) const </td></tr>
<tr class="separator:a22a57220d2bcbe1018421db665a18f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bfb6fc459b8f596f5b9370e88f90f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a13bfb6fc459b8f596f5b9370e88f90f3">Invert</a> () const </td></tr>
<tr class="separator:a13bfb6fc459b8f596f5b9370e88f90f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f136e8c8fafe7faca1a1ccc3ab3c89e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a9f136e8c8fafe7faca1a1ccc3ab3c89e">Lengthen</a> (const float percent) const </td></tr>
<tr class="separator:a9f136e8c8fafe7faca1a1ccc3ab3c89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac558f376a4ad4e98ed94f45067b9888b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ac558f376a4ad4e98ed94f45067b9888b">Include</a> (const T x) const </td></tr>
<tr class="separator:ac558f376a4ad4e98ed94f45067b9888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ca768fbeaf9bd36c5a7e287bbfdf35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0ca768fbeaf9bd36c5a7e287bbfdf35"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#aa0ca768fbeaf9bd36c5a7e287bbfdf35">operator==</a> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;rhs) const </td></tr>
<tr class="memdesc:aa0ca768fbeaf9bd36c5a7e287bbfdf35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality is strict. No epsilon checking here. <br/></td></tr>
<tr class="separator:aa0ca768fbeaf9bd36c5a7e287bbfdf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeef90a8dd2fabc03bd9458a0ffd121d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeef90a8dd2fabc03bd9458a0ffd121d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;rhs) const </td></tr>
<tr class="separator:aeeef90a8dd2fabc03bd9458a0ffd121d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad140843bc2218bd701ce12034b024240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad140843bc2218bd701ce12034b024240"></a>
<a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ad140843bc2218bd701ce12034b024240">operator*</a> (const float s) const </td></tr>
<tr class="memdesc:ad140843bc2218bd701ce12034b024240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale by multiplying by a scalar. <br/></td></tr>
<tr class="separator:ad140843bc2218bd701ce12034b024240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bea0f2a960a439b576c8c5811d98b57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bea0f2a960a439b576c8c5811d98b57"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a6bea0f2a960a439b576c8c5811d98b57">start</a> () const </td></tr>
<tr class="memdesc:a6bea0f2a960a439b576c8c5811d98b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors. <br/></td></tr>
<tr class="separator:a6bea0f2a960a439b576c8c5811d98b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63174a1e6b88408040982903fae7452a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63174a1e6b88408040982903fae7452a"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a63174a1e6b88408040982903fae7452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0185438e4e820d49db5d22b1803f6b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0185438e4e820d49db5d22b1803f6b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_start</b> (const T <a class="el" href="classmotive_1_1_range_t.html#a6bea0f2a960a439b576c8c5811d98b57">start</a>)</td></tr>
<tr class="separator:ab0185438e4e820d49db5d22b1803f6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3484f675ac6ca36c936e841c25b4a833"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3484f675ac6ca36c936e841c25b4a833"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_end</b> (const T end)</td></tr>
<tr class="separator:a3484f675ac6ca36c936e841c25b4a833"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a98027c065abf86bd452e997072417009"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a98027c065abf86bd452e997072417009">Intersect</a> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;a, const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;b)</td></tr>
<tr class="separator:a98027c065abf86bd452e997072417009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9745d01a4990969f6b9dfaa3dd1c8c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9745d01a4990969f6b9dfaa3dd1c8c0"></a>
static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#aa9745d01a4990969f6b9dfaa3dd1c8c0">Union</a> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;a, const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;b)</td></tr>
<tr class="memdesc:aa9745d01a4990969f6b9dfaa3dd1c8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest range that covers all of 'a' and 'b'. <br/></td></tr>
<tr class="separator:aa9745d01a4990969f6b9dfaa3dd1c8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3aac46a4d77ba4cb725d34d4f52b775"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ae3aac46a4d77ba4cb725d34d4f52b775">ValuesInRange</a> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;range, T epsilon, size_t num_values, T *values)</td></tr>
<tr class="separator:ae3aac46a4d77ba4cb725d34d4f52b775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f61947bda561a19f2086a47243f0da7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f61947bda561a19f2086a47243f0da7"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:a5f61947bda561a19f2086a47243f0da7"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ValuesInRange</b> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> &amp;range, T epsilon, <a class="el" href="structmotive_1_1_range_t_1_1_t_array.html">TArray</a>&lt; kMaxLen &gt; *values)</td></tr>
<tr class="separator:a5f61947bda561a19f2086a47243f0da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e5911db343a70ac6553bb93988df38"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a63e5911db343a70ac6553bb93988df38">IntersectRanges</a> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> *a, size_t len_a, const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> *b, size_t len_b, <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> *intersections, <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> *gaps=nullptr, size_t *len_gaps=nullptr)</td></tr>
<tr class="separator:a63e5911db343a70ac6553bb93988df38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d90e1f7ec6ff4d87a20a07e02be06b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3d90e1f7ec6ff4d87a20a07e02be06b"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:ab3d90e1f7ec6ff4d87a20a07e02be06b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IntersectRanges</b> (const <a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;a, const <a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;b, <a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen *kMaxLen &gt; *intersections, <a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen *kMaxLen &gt; *gaps=nullptr)</td></tr>
<tr class="separator:ab3d90e1f7ec6ff4d87a20a07e02be06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6c1d11efcb28b895ea4c2623c66faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a6c1d11efcb28b895ea4c2623c66faa"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a6a6c1d11efcb28b895ea4c2623c66faa">IndexOfLongest</a> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> *ranges, size_t len)</td></tr>
<tr class="memdesc:a6a6c1d11efcb28b895ea4c2623c66faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the longest range in <code>ranges</code>. <br/></td></tr>
<tr class="separator:a6a6c1d11efcb28b895ea4c2623c66faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efc7365584a8312fbb2bd22265506e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4efc7365584a8312fbb2bd22265506e5"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:a4efc7365584a8312fbb2bd22265506e5"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexOfLongest</b> (const <a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;ranges)</td></tr>
<tr class="separator:a4efc7365584a8312fbb2bd22265506e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69599295afdb9cc8b215a08923fdc07a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69599295afdb9cc8b215a08923fdc07a"></a>
static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a69599295afdb9cc8b215a08923fdc07a">IndexOfShortest</a> (const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> *ranges, size_t len)</td></tr>
<tr class="memdesc:a69599295afdb9cc8b215a08923fdc07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the shortest range in <code>ranges</code>. <br/></td></tr>
<tr class="separator:a69599295afdb9cc8b215a08923fdc07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4210ee60ae1ce16dab01c2e2449cca44"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4210ee60ae1ce16dab01c2e2449cca44"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:a4210ee60ae1ce16dab01c2e2449cca44"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IndexOfShortest</b> (const <a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;ranges)</td></tr>
<tr class="separator:a4210ee60ae1ce16dab01c2e2449cca44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b662eb3cbbc8290ab5c045e8f0d1090"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b662eb3cbbc8290ab5c045e8f0d1090"></a>
static T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a0b662eb3cbbc8290ab5c045e8f0d1090">ClampToClosest</a> (T x, const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> *ranges, size_t len)</td></tr>
<tr class="memdesc:a0b662eb3cbbc8290ab5c045e8f0d1090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the shortest range in <code>ranges</code>. <br/></td></tr>
<tr class="separator:a0b662eb3cbbc8290ab5c045e8f0d1090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43995462051a895c745469545d347b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="af43995462051a895c745469545d347b7"></a>
template&lt;size_t kMaxLen&gt; </td></tr>
<tr class="memitem:af43995462051a895c745469545d347b7"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ClampToClosest</b> (T x, const <a class="el" href="structmotive_1_1_range_t_1_1_range_array.html">RangeArray</a>&lt; kMaxLen &gt; &amp;ranges)</td></tr>
<tr class="separator:af43995462051a895c745469545d347b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8fcec3fd10a7950698c2006c705c1a"><td class="memTemplParams" colspan="2">template&lt;typename S , typename F &gt; </td></tr>
<tr class="memitem:aba8fcec3fd10a7950698c2006c705c1a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#aba8fcec3fd10a7950698c2006c705c1a">CoversLambda</a> (const S *array, size_t len, const F &amp;f)</td></tr>
<tr class="separator:aba8fcec3fd10a7950698c2006c705c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dac17430e75a1a7b2cf73642d4d8d2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dac17430e75a1a7b2cf73642d4d8d2e"></a>
static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a8dac17430e75a1a7b2cf73642d4d8d2e">Covers</a> (const T *array, size_t len)</td></tr>
<tr class="memdesc:a8dac17430e75a1a7b2cf73642d4d8d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the range that covers all values in <code>array</code>. <br/></td></tr>
<tr class="separator:a8dac17430e75a1a7b2cf73642d4d8d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2cb882d5d4f939ee4f8e345289204c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add2cb882d5d4f939ee4f8e345289204c"></a>
static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#add2cb882d5d4f939ee4f8e345289204c">Full</a> ()</td></tr>
<tr class="memdesc:add2cb882d5d4f939ee4f8e345289204c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complete range. Every T is contained in this range. <br/></td></tr>
<tr class="separator:add2cb882d5d4f939ee4f8e345289204c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb33d4f02534e39a49d4969940246b99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#aeb33d4f02534e39a49d4969940246b99">Empty</a> ()</td></tr>
<tr class="separator:aeb33d4f02534e39a49d4969940246b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6556c418e3ff235f5bcce8b68cfb84e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6556c418e3ff235f5bcce8b68cfb84e"></a>
static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#ab6556c418e3ff235f5bcce8b68cfb84e">Positive</a> ()</td></tr>
<tr class="memdesc:ab6556c418e3ff235f5bcce8b68cfb84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of positive numbers: [0, +infinity]. <br/></td></tr>
<tr class="separator:ab6556c418e3ff235f5bcce8b68cfb84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e75473f46843cda44c6716f76ba952e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e75473f46843cda44c6716f76ba952e"></a>
static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_range_t.html#a4e75473f46843cda44c6716f76ba952e">Negative</a> ()</td></tr>
<tr class="memdesc:a4e75473f46843cda44c6716f76ba952e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of negative numbers.: [-infinity, 0]. <br/></td></tr>
<tr class="separator:a4e75473f46843cda44c6716f76ba952e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5dc35956e960d733f40a81160778af9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Clamp </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>x</code> if it is within the range. Otherwise, returns start_ or end_, whichever is closer to <code>x</code>. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="a725ec57fb75410d7f8fe82eba758fcd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ClampAfterStart </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clamp <code>x</code> so it is inside the start bound. Can save cycles if you already know that <code>x</code> is inside the end bound. </p>

</div>
</div>
<a class="anchor" id="a9de954293531bb29db954a1cee4c9d89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ClampBeforeEnd </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clamp <code>x</code> so it is inside the end bound. Can save cycles if you already know that <code>x</code> is inside the start bound. </p>

</div>
</div>
<a class="anchor" id="a2bfa9c82690b004a7587f0c06c8c4932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ContainsExcludingEnd </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if <code>x</code> is in [start_, end_), i.e. the range that includes the start bound but not the end bound. </p>

</div>
</div>
<a class="anchor" id="abfe036fb375a7c8f549649c55bc0e74a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ContainsExcludingStart </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if <code>x</code> is in (start_, end_], i.e. the range that includes the end bound but not the start bound. </p>

</div>
</div>
<a class="anchor" id="a22a57220d2bcbe1018421db665a18f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ContainsWithTolerance </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>percent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if <code>x</code> is in [start_ - tolerance, end_ + tolerance], where tolerance = <a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length()</a> * percent. </p>

</div>
</div>
<a class="anchor" id="aba8fcec3fd10a7950698c2006c705c1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename S , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt;T&gt; <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::CoversLambda </td>
          <td>(</td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the range that covers all values in f(array). f is a lambda to calculate T from S. See <a class="el" href="classmotive_1_1_range_t.html#a8dac17430e75a1a7b2cf73642d4d8d2e" title="Return the range that covers all values in array. ">Covers()</a> for a simple example. In general, if your S has a function <code>T GetValue()</code>, then your lambda can look something like, const RangeT&lt;T&gt; range = <a class="el" href="classmotive_1_1_range_t.html#aba8fcec3fd10a7950698c2006c705c1a">RangeT&lt;T&gt;::CoversLambda</a>( s_array, len, [](const S&amp; s) { return s.GetValue(); }); </p>

</div>
</div>
<a class="anchor" id="a19147d320516298553c578b9c8c4d2e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::DistanceFrom </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns distance outside of the range. If inside the range, returns 0. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="aeb33d4f02534e39a49d4969940246b99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt;T&gt; <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the most empty range possible. The lower bound is greater than everything, and the upper bound is less than everything. Useful when finding the min/max values of an array of numbers. </p>

</div>
</div>
<a class="anchor" id="ac558f376a4ad4e98ed94f45067b9888b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a> <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Include </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the smallest range that contains both <code>x</code> and the range in <code>this</code>. </p>

</div>
</div>
<a class="anchor" id="a98027c065abf86bd452e997072417009"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmotive_1_1_range_t.html">RangeT</a> <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the overlap of 'a' and 'b', or an invalid range if they do not overlap at all. When 'a' and 'b' don't overlap at all, calling Invert on the returned range will give the gap between 'a' and 'b'. </p>

</div>
</div>
<a class="anchor" id="a63e5911db343a70ac6553bb93988df38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::IntersectRanges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>intersections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>gaps</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len_gaps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Intersect every element of 'a' with every element of 'b'. Append intersections to 'intersections'. Note that 'intersections' is not reset at the start of the call. </p>

</div>
</div>
<a class="anchor" id="a13bfb6fc459b8f596f5b9370e88f90f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a> <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap start and end. When 'a' and 'b' don't overlap, if you invert the return value of Range::Intersect(a, b), you'll get the gap between 'a' and 'b'. </p>

</div>
</div>
<a class="anchor" id="afa92310288b7f52713948cce217fa73b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the span of the range. Returns 0 when only one number in range. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="a9f136e8c8fafe7faca1a1ccc3ab3c89e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmotive_1_1_range_t.html">RangeT</a> <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Lengthen </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>percent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a range that is 'percent' longer. If 'percent' is &lt; 1.0, then returned range will actually be shorter. </p>

</div>
</div>
<a class="anchor" id="a3c61742ac4a96681f47410d3efc9e541"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Lerp </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>percent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lerps between the start and the end. 'percent' of 0 returns start. 'percent' of 1 returns end. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="ae531b10c3ed174bf0445903e6ece2ebd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Middle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the mid-point of the range, rounded down for integers. Behavior is undefined for invalid regions. </p>

</div>
</div>
<a class="anchor" id="a0610a07e387639f58f7aac571f899acb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ModDiff </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModularDirection&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference from 'a' to 'b' that satisfies the 'direction' criteria. </p>

</div>
</div>
<a class="anchor" id="a585e3a5bb49d9d376b45d770a37fcea2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ModDiffClose </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In modular arithmetic, you can get from 'a' to 'b' by going directly, or by wrapping around. Return the closest difference from 'a' to 'b' under modular arithmetic. </p>

</div>
</div>
<a class="anchor" id="a518ce1b36483597509cc01ac373f7c1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ModDiffNegative </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference from 'a' to 'b' under modular arithmetic that is negative. </p>

</div>
</div>
<a class="anchor" id="a8affb4d0d36e47bb3b84a998f8dae433"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ModDiffPositive </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the difference from 'a' to 'b' under modular arithmetic that is positive. </p>

</div>
</div>
<a class="anchor" id="ac88728e70338d1dc1c944becd9ad43d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ModularAdjustment </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: <a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length()</a> if <code>x</code> is below the valid range -Length() if <code>x</code> is above the valid range 0 if <code>x</code> is within the valid range. </p>

</div>
</div>
<a class="anchor" id="a02e9e9a7168de1c6221ee28713b27eba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Normalize </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure <code>x</code> is within the valid constraint range, by subtracting or adding <a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length()</a> to it. <code>x</code> must be within +-Length() of the range bounds. This is a reasonable restriction in most cases (such as after an arithmetic operation). For cases where <code>x</code> may be wildly outside the range, use <a class="el" href="classmotive_1_1_range_t.html#a10b0cff76a3faa187c3c0078d1b934b3">NormalizeCloseValue()</a> or <a class="el" href="classmotive_1_1_range_t.html#ae474477f86d6adbc54da2b2f15054ebe">NormalizeWildValue()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a10b0cff76a3faa187c3c0078d1b934b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::NormalizeCloseValue </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure <code>x</code> is within the valid constraint range, by subtracting or adding <a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length()</a> to it repeatedly. <code>x</code> must be within +-kMaxAdjustments * <a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length()</a> of the range bounds for this function to be effective. If its greater, we end up calling <a class="el" href="classmotive_1_1_range_t.html#ae474477f86d6adbc54da2b2f15054ebe">NormalizeWildValue()</a>, so you'd be better off calling <a class="el" href="classmotive_1_1_range_t.html#ae474477f86d6adbc54da2b2f15054ebe">NormalizeWildValue()</a> from the beginning. This function is intended to be called in situations where <code>x</code> is almost always within one or two lengths of being normalized, so we don't want to incur the division cost of <a class="el" href="classmotive_1_1_range_t.html#ae474477f86d6adbc54da2b2f15054ebe">NormalizeWildValue()</a>. It's still guaranteed to return a normalized value, however. </p>

</div>
</div>
<a class="anchor" id="ae474477f86d6adbc54da2b2f15054ebe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::NormalizeWildValue </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure <code>x</code> is within the valid constraint range, by subtracting multiples of <a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length()</a> from it until it is. <code>x</code> can be any value. </p>

</div>
</div>
<a class="anchor" id="afa2966ba7ac9a3f3b2c57b980b5f6fff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::Percent </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns percent 0~1, from start to end. <em>Not</em> clamped to 0~1. 0 ==&gt; start; 1 ==&gt; end; 0.5 ==&gt; <a class="el" href="classmotive_1_1_range_t.html#ae531b10c3ed174bf0445903e6ece2ebd">Middle()</a>; -1 ==&gt; start - <a class="el" href="classmotive_1_1_range_t.html#afa92310288b7f52713948cce217fa73b">Length()</a> </p>

</div>
</div>
<a class="anchor" id="a8980ceb97c9dac550e353633ec732f20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::PercentClamped </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns percent 0~1, from start to end. Clamped to 0~1. 0 ==&gt; start or earlier; 1 ==&gt; end or later; 0.5 ==&gt; <a class="el" href="classmotive_1_1_range_t.html#ae531b10c3ed174bf0445903e6ece2ebd">Middle()</a> </p>

</div>
</div>
<a class="anchor" id="ae3aac46a4d77ba4cb725d34d4f52b775"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classmotive_1_1_range_t.html">motive::RangeT</a>&lt; T &gt;::ValuesInRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_range_t.html">RangeT</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Only keep entries in 'values' if they are in (range.start - epsition, range.end + epsilon). Any values that are kept are clamped to 'range'.</p>
<p>This function is useful when floating point precision error might put a value slightly outside 'range' even though mathematically it should be inside 'range'. This often happens with values right on the border of the valid range. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="range_8h_source.html">range.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>

<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Motive Animation System: motive::CompactSpline Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Motive Animation System
   </div>
   <div style="font-size:12px;">
	 An open source project by
     <a href="https://developers.google.com/games/#Tools">FPL</a>.
  </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.html"><span>Building</span></a></li>
      <li><a href="usergroup1.html"><span>Programmer's&#160;Guide</span></a></li>
      <li class="current"><a href="motive_api_reference.html"><span>API&#160;Reference</span></a></li>
      <li><a href="motive_readme.html"><span>Readme</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmotive_1_1_compact_spline.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmotive_1_1_compact_spline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">motive::CompactSpline Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represent a smooth curve in a small amount of memory.  
 <a href="classmotive_1_1_compact_spline.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="compact__spline_8h_source.html">compact_spline.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represent a smooth curve in a small amount of memory. </p>
<p>This spline interpolates a series of (x, y, derivative) nodes to create a smooth curve.</p>
<p>This class holds a series of such nodes, and aids with the construction of that series by inserting extra nodes when extra smoothness is required.</p>
<p>The data in this class is compacted as quantized values. It's not intended to be read directly. You should use the <a class="el" href="classmotive_1_1_bulk_spline_evaluator.html" title="Traverse through a set of splines in a performant way. ">BulkSplineEvaluator</a> to update and read values from the splines in a performant manner. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a76cb939959650b06e16ce1ac45924c2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76cb939959650b06e16ce1ac45924c2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CompactSpline</b> (const <a class="el" href="classmotive_1_1_range_t.html">Range</a> &amp;y_range, const float x_granularity, const int num_nodes=0)</td></tr>
<tr class="separator:a76cb939959650b06e16ce1ac45924c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5920e063b8ac75281b67e0b2c879aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#abc5920e063b8ac75281b67e0b2c879aa">CompactSpline</a> (const <a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> &amp;rhs)</td></tr>
<tr class="separator:abc5920e063b8ac75281b67e0b2c879aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860024d7511c82eeba48c70836555e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae860024d7511c82eeba48c70836555e9"></a>
<a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> &amp;rhs)</td></tr>
<tr class="separator:ae860024d7511c82eeba48c70836555e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3d2da981d2cb097fe5ec354e6c4b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a7d3d2da981d2cb097fe5ec354e6c4b3a">Init</a> (const <a class="el" href="classmotive_1_1_range_t.html">Range</a> &amp;y_range, const float x_granularity, const int num_nodes=0)</td></tr>
<tr class="separator:a7d3d2da981d2cb097fe5ec354e6c4b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6b65c9aa5be6a03ac2a6e914ee70d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#add6b65c9aa5be6a03ac2a6e914ee70d6">AddNode</a> (const float x, const float y, const float derivative, const CompactSplineAddMethod method=kEnsureCubicWellBehaved)</td></tr>
<tr class="separator:add6b65c9aa5be6a03ac2a6e914ee70d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377ef469b252cd6ab73f652c9307412b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a377ef469b252cd6ab73f652c9307412b">AddNodeVerbatim</a> (const CompactSplineXGrain x, const CompactSplineYRung y, const CompactSplineAngle angle)</td></tr>
<tr class="separator:a377ef469b252cd6ab73f652c9307412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fd27d961a8cf4975689521862f49ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64fd27d961a8cf4975689521862f49ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a64fd27d961a8cf4975689521862f49ce">Clear</a> ()</td></tr>
<tr class="memdesc:a64fd27d961a8cf4975689521862f49ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes from the spline. <br/></td></tr>
<tr class="separator:a64fd27d961a8cf4975689521862f49ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1832ac9b92ea996676ea73c769b8ae1e"><td class="memItemLeft" align="right" valign="top">CompactSplineIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a1832ac9b92ea996676ea73c769b8ae1e">IndexForX</a> (const float x, const CompactSplineIndex guess_index) const </td></tr>
<tr class="separator:a1832ac9b92ea996676ea73c769b8ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2b68788056f5ced1e03102bef83cda"><td class="memItemLeft" align="right" valign="top">CompactSplineIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a7b2b68788056f5ced1e03102bef83cda">IndexForXAllowingRepeat</a> (const float x, const CompactSplineIndex guess_index, const bool repeat, float *final_x) const </td></tr>
<tr class="separator:a7b2b68788056f5ced1e03102bef83cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd8b48744fbe4e9a78ee8b4e083d462"><td class="memItemLeft" align="right" valign="top">CompactSplineIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a7dd8b48744fbe4e9a78ee8b4e083d462">ClampIndex</a> (const CompactSplineIndex index, float *x) const </td></tr>
<tr class="separator:a7dd8b48744fbe4e9a78ee8b4e083d462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730b5bbf2fe9487fcb03903411f13747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a730b5bbf2fe9487fcb03903411f13747"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>StartX</b> () const </td></tr>
<tr class="separator:a730b5bbf2fe9487fcb03903411f13747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7961dc8b9d6a47016e474d770d856809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7961dc8b9d6a47016e474d770d856809"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>StartY</b> () const </td></tr>
<tr class="separator:a7961dc8b9d6a47016e474d770d856809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fd2b2f022172c21a57c36be23cf437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31fd2b2f022172c21a57c36be23cf437"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>StartDerivative</b> () const </td></tr>
<tr class="separator:a31fd2b2f022172c21a57c36be23cf437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e2a4569b5f8b865a7fe061cf11cb2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27e2a4569b5f8b865a7fe061cf11cb2a"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>EndX</b> () const </td></tr>
<tr class="separator:a27e2a4569b5f8b865a7fe061cf11cb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95fc04620afd3825df34b4a79532fb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac95fc04620afd3825df34b4a79532fb2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>EndY</b> () const </td></tr>
<tr class="separator:ac95fc04620afd3825df34b4a79532fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dd2c20d08a0f733ea04a5ba4c57acc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2dd2c20d08a0f733ea04a5ba4c57acc"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>EndDerivative</b> () const </td></tr>
<tr class="separator:ac2dd2c20d08a0f733ea04a5ba4c57acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e11ea4f2c6a981fb8683e6366455b62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e11ea4f2c6a981fb8683e6366455b62"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>NodeX</b> (const CompactSplineIndex index) const </td></tr>
<tr class="separator:a3e11ea4f2c6a981fb8683e6366455b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bd72d8649fb4f0b2ad1cc16148c6a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65bd72d8649fb4f0b2ad1cc16148c6a5"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>NodeY</b> (const CompactSplineIndex index) const </td></tr>
<tr class="separator:a65bd72d8649fb4f0b2ad1cc16148c6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f3e66f79b16854c00222176b9cb9f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24f3e66f79b16854c00222176b9cb9f2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>NodeDerivative</b> (const CompactSplineIndex index) const </td></tr>
<tr class="separator:a24f3e66f79b16854c00222176b9cb9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace447e527423114763c57f271a28182e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace447e527423114763c57f271a28182e"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>LengthX</b> () const </td></tr>
<tr class="separator:ace447e527423114763c57f271a28182e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab096f64427d099e5d54daa984da36b44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab096f64427d099e5d54daa984da36b44"></a>
<a class="el" href="classmotive_1_1_range_t.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RangeX</b> () const </td></tr>
<tr class="separator:ab096f64427d099e5d54daa984da36b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220bab7a59be6f5610d72d6d7a2f4915"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a220bab7a59be6f5610d72d6d7a2f4915"></a>
const <a class="el" href="classmotive_1_1_range_t.html">Range</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>RangeY</b> () const </td></tr>
<tr class="separator:a220bab7a59be6f5610d72d6d7a2f4915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89b1dc71660cc9564de8c8298280955"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#ae89b1dc71660cc9564de8c8298280955">YCalculatedSlowly</a> (const float x) const </td></tr>
<tr class="separator:ae89b1dc71660cc9564de8c8298280955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7babce81e3bed518303c9e02128fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a9a7babce81e3bed518303c9e02128fa8">Ys</a> (const float start_x, const float delta_x, const int num_ys, float *ys) const </td></tr>
<tr class="separator:a9a7babce81e3bed518303c9e02128fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0d492cdc5a171a3ab35f129a15e628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c0d492cdc5a171a3ab35f129a15e628"></a>
<a class="el" href="classmotive_1_1_range_t.html">Range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a1c0d492cdc5a171a3ab35f129a15e628">RangeX</a> (const CompactSplineIndex index) const </td></tr>
<tr class="memdesc:a1c0d492cdc5a171a3ab35f129a15e628"><td class="mdescLeft">&#160;</td><td class="mdescRight">The start and end x-values covered by the segment after <code>index</code>. <br/></td></tr>
<tr class="separator:a1c0d492cdc5a171a3ab35f129a15e628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19e2782f1456f94a711a19eab520d19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmotive_1_1_cubic_init.html">CubicInit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#ac19e2782f1456f94a711a19eab520d19">CreateCubicInit</a> (const CompactSplineIndex index) const </td></tr>
<tr class="separator:ac19e2782f1456f94a711a19eab520d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5344b150276fca5a4504b62abdd0efd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5344b150276fca5a4504b62abdd0efd8"></a>
CompactSplineIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a5344b150276fca5a4504b62abdd0efd8">NumNodes</a> () const </td></tr>
<tr class="memdesc:a5344b150276fca5a4504b62abdd0efd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in this spline. <br/></td></tr>
<tr class="separator:a5344b150276fca5a4504b62abdd0efd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1831d4065dab359a5e8f77476d36ffe9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1831d4065dab359a5e8f77476d36ffe9"></a>
const CompactSplineNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a1831d4065dab359a5e8f77476d36ffe9">nodes</a> () const </td></tr>
<tr class="memdesc:a1831d4065dab359a5e8f77476d36ffe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return const versions of internal values. For serialization. <br/></td></tr>
<tr class="separator:a1831d4065dab359a5e8f77476d36ffe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205fadcfc8b56ec201530aaa2f7325c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205fadcfc8b56ec201530aaa2f7325c9"></a>
const <a class="el" href="classmotive_1_1_range_t.html">Range</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>y_range</b> () const </td></tr>
<tr class="separator:a205fadcfc8b56ec201530aaa2f7325c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab523234b41bff075e874564f13a79"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81ab523234b41bff075e874564f13a79"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>x_granularity</b> () const </td></tr>
<tr class="separator:a81ab523234b41bff075e874564f13a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a86eabaa270928ebfe4e046b3d7fbdcbf"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a86eabaa270928ebfe4e046b3d7fbdcbf">RecommendXGranularity</a> (const float max_x)</td></tr>
<tr class="separator:a86eabaa270928ebfe4e046b3d7fbdcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4464e797275226eafceefd930ddfe129"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a4464e797275226eafceefd930ddfe129">BulkYs</a> (const <a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> *const splines, const int num_splines, const float start_x, const float delta_x, const size_t num_ys, float *ys)</td></tr>
<tr class="separator:a4464e797275226eafceefd930ddfe129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830ce69c2d979703be803414fed510c9"><td class="memTemplParams" colspan="2">template&lt;int kDimensions&gt; </td></tr>
<tr class="memitem:a830ce69c2d979703be803414fed510c9"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmotive_1_1_compact_spline.html#a830ce69c2d979703be803414fed510c9">BulkYs</a> (const <a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> *const splines, const float start_x, const float delta_x, const size_t num_ys, mathfu::VectorPacked&lt; float, kDimensions &gt; *ys)</td></tr>
<tr class="separator:a830ce69c2d979703be803414fed510c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abc5920e063b8ac75281b67e0b2c879aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">motive::CompactSpline::CompactSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy constructors, copy operator, and destructor are all default implementations, but must be specified explicitly because CompactSplineNode is not specified in the header file. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="add6b65c9aa5be6a03ac2a6e914ee70d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void motive::CompactSpline::AddNode </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompactSplineAddMethod&#160;</td>
          <td class="paramname"><em>method</em> = <code>kEnsureCubicWellBehaved</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a node to the end of the spline. Depending on the method, an intermediate node may also be inserted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Must be greater than the x-value of the last spline node. If not, this call is a nop. </td></tr>
    <tr><td class="paramname">y</td><td>Must be within the <code>y_range</code> specified in <a class="el" href="classmotive_1_1_compact_spline.html#a7d3d2da981d2cb097fe5ec354e6c4b3a">Init()</a>. </td></tr>
    <tr><td class="paramname">derivative</td><td>No restrictions, but excessively large values may still result in overshoot, even with an intermediate node. </td></tr>
    <tr><td class="paramname">method</td><td>If kAddWithoutModification, adds the node and does nothing else. If kEnsureCubicWellBehaved, adds the node and (if required) inserts another node in the middle so that the individual cubics have uniform curvature. Uniform curvature means always curving upward or always curving downward. See docs/dual_cubics.pdf for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a377ef469b252cd6ab73f652c9307412b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void motive::CompactSpline::AddNodeVerbatim </td>
          <td>(</td>
          <td class="paramtype">const CompactSplineXGrain&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompactSplineYRung&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompactSplineAngle&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add values without converting them. Useful when initializing from precalculated data. </p>

</div>
</div>
<a class="anchor" id="a4464e797275226eafceefd930ddfe129"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void motive::CompactSpline::BulkYs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> *const&#160;</td>
          <td class="paramname"><em>splines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_splines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>start_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast evaluation of several splines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">splines</td><td>input splines of length <code>num_splines</code>. </td></tr>
    <tr><td class="paramname">num_splines</td><td>number of splines to evaluate. </td></tr>
    <tr><td class="paramname">start_x</td><td>starting point for every spline. </td></tr>
    <tr><td class="paramname">delta_x</td><td>increment for each output y. </td></tr>
    <tr><td class="paramname">num_ys</td><td>length of the <code>ys</code> array. </td></tr>
    <tr><td class="paramname">ys</td><td>two dimensional output array, ys[num_ys][num_splines]. ys[0] are <code>splines</code> evaluated at start_x. ys[num_ys - 1] are <code>splines</code> evaluated at start_x + delta_x * num_ys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a830ce69c2d979703be803414fed510c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int kDimensions&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void motive::CompactSpline::BulkYs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_compact_spline.html">CompactSpline</a> *const&#160;</td>
          <td class="paramname"><em>splines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>start_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mathfu::VectorPacked&lt; float, kDimensions &gt; *&#160;</td>
          <td class="paramname"><em>ys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast evaluation of several splines, with mathfu::VectorPacked interface. Useful for evaluate three splines which together form a mathfu::vec3, for instance. </p>

</div>
</div>
<a class="anchor" id="a7dd8b48744fbe4e9a78ee8b4e083d462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CompactSplineIndex motive::CompactSpline::ClampIndex </td>
          <td>(</td>
          <td class="paramtype">const CompactSplineIndex&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns closest index between 0 and <a class="el" href="classmotive_1_1_compact_spline.html#a5344b150276fca5a4504b62abdd0efd8" title="Returns the number of nodes in this spline. ">NumNodes()</a> - 1. Clamps <code>x</code> to a value in the range of index. <code>index</code> must be a valid value: i.e. kBeforeSplineIndex, kAfterSplineIndex, or between 0..<a class="el" href="classmotive_1_1_compact_spline.html#a5344b150276fca5a4504b62abdd0efd8" title="Returns the number of nodes in this spline. ">NumNodes()</a>-1. </p>

</div>
</div>
<a class="anchor" id="ac19e2782f1456f94a711a19eab520d19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmotive_1_1_cubic_init.html">CubicInit</a> motive::CompactSpline::CreateCubicInit </td>
          <td>(</td>
          <td class="paramtype">const CompactSplineIndex&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialization parameters for a cubic curve that starts at <code>index</code> and ends at <code>index</code> + 1. Or a constant curve if <code>index</code> is kBeforeSplineIndex or kAfterSplineIndex. </p>

</div>
</div>
<a class="anchor" id="a1832ac9b92ea996676ea73c769b8ae1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CompactSplineIndex motive::CompactSpline::IndexForX </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompactSplineIndex&#160;</td>
          <td class="paramname"><em>guess_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return index of the first node before <code>x</code>. If <code>x</code> is before the first node, return kBeforeSplineIndex. If <code>x</code> is past the last node, return kAfterSplineIndex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-value in the spline. Most often, the x-axis represents time. </td></tr>
    <tr><td class="paramname">guess_index</td><td>Best guess at what the index for <code>x</code> will be. Often the caller will be traversing from low to high x, so a good guess is the index after the current index. If you have no idea, set to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b2b68788056f5ced1e03102bef83cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CompactSplineIndex motive::CompactSpline::IndexForXAllowingRepeat </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CompactSplineIndex&#160;</td>
          <td class="paramname"><em>guess_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>final_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>repeat</code> is true, loop to x = 0 when <code>x</code> &gt;= EndX(). If <code>repeat</code> is false, same as <a class="el" href="classmotive_1_1_compact_spline.html#a1832ac9b92ea996676ea73c769b8ae1e">IndexForX()</a>. </p>

</div>
</div>
<a class="anchor" id="a7d3d2da981d2cb097fe5ec354e6c4b3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void motive::CompactSpline::Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmotive_1_1_range_t.html">Range</a> &amp;&#160;</td>
          <td class="paramname"><em>y_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x_granularity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_nodes</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The range of values for x and y must be specified at spline creation time and cannot be changed afterwards. Empties all nodes, if we have any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_range</td><td>The upper and lower bounds for y-values in the nodes. The more narrow this is, the better the precision of the fixed point numbers. Note that you should add 10% padding here, since AddNode may insert a smoothing node that is slightly beyond the source y range. </td></tr>
    <tr><td class="paramname">x_granularity</td><td>The minimum increment of x-values. If you're working with a spline changes at most 30 times per second, and your x is in units of 1/1000th of a second, then x_granularity = 33 is a good baseline. You'll probably want granularity around 1/50th of that baseline value, though, since AddNode may insert smoothing nodes at intermediate x's. In our example here, you could set x_granularity near 33 / 50. For ease of debugging, an x_granularity of 0.5 or 1 is probably best. </td></tr>
    <tr><td class="paramname">num_nodes</td><td>A hint for how many nodes are expected to be added. Try to get this close or slightly too high, to avoid reallocation of internal memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86eabaa270928ebfe4e046b3d7fbdcbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float motive::CompactSpline::RecommendXGranularity </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>max_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recommend a granularity given a maximal-x value. We want to have the most precise granularity when quantizing x's. </p>

</div>
</div>
<a class="anchor" id="ae89b1dc71660cc9564de8c8298280955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float motive::CompactSpline::YCalculatedSlowly </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate spline at <code>x</code>. This function is somewhat slow because it must find the node for <code>x</code> and create the cubic before the returned y can be evaluated. If calling from inside a loop, replace the loop with one call to <a class="el" href="classmotive_1_1_compact_spline.html#a9a7babce81e3bed518303c9e02128fa8">Ys()</a>, which is significantly faster. </p>

</div>
</div>
<a class="anchor" id="a9a7babce81e3bed518303c9e02128fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void motive::CompactSpline::Ys </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>start_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast evaluation of a subset of the x-domain of the spline. Spline is evaluated from <code>start_x</code> and subsequent intervals of <code>delta_x</code>. Evaluated values are returned in <code>ys</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="compact__spline_8h_source.html">compact_spline.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
